<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Isolaton and Relation — 双人同屏（纯静态）</title>
  <!-- Tailwind via CDN (static page; requires internet). If you want fully offline, tell me and I'll inline minimal CSS. -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- React 18 UMD -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <!-- Babel for JSX (static; requires internet). For production, I can also provide a precompiled no-Babel build. -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    /* Prevent pinch zoom weirdness on some mobile browsers while still allowing scroll */
    html, body { height: 100%; }
  </style>
</head>
<body class="bg-neutral-50">
  <div id="root"></div>

  <script type="text/babel">
    const { useEffect, useMemo, useRef, useState } = React;

    // ======= Core rules helpers =======
    const N = 16;

    function floorDist(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      return Math.floor(Math.hypot(dx, dy));
    }

    function ceilLen(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      return Math.ceil(Math.hypot(dx, dy));
    }

    function isDiagonal(a, b) {
      const dx = Math.abs(a.x - b.x);
      const dy = Math.abs(a.y - b.y);
      return dx === dy && dx !== 0;
    }

    // Segment intersection for lattice-point crossings (including touching).
    // Counts a crossing only when intersection point is exactly a lattice point (integers), OR shared endpoint.
    function segmentLatticeIntersection(p1, p2, q1, q2) {
      const eps = 1e-9;

      const onSegment = (a, b, c) =>
        (Math.min(a.x, c.x) - eps <= b.x && b.x <= Math.max(a.x, c.x) + eps &&
         Math.min(a.y, c.y) - eps <= b.y && b.y <= Math.max(a.y, c.y) + eps);

      const orient = (a, b, c) => {
        const v = (b.y - a.y) * (c.x - b.x) - (b.x - a.x) * (c.y - b.y);
        if (Math.abs(v) < eps) return 0;
        return v > 0 ? 1 : 2;
      };

      const shareEndpoint = (a, b, c, d) => {
        const eq = (u, v) => u.x === v.x && u.y === v.y;
        if (eq(a, c)) return a;
        if (eq(a, d)) return a;
        if (eq(b, c)) return b;
        if (eq(b, d)) return b;
        return null;
      };

      const shared = shareEndpoint(p1, p2, q1, q2);
      if (shared) return shared;

      const o1 = orient(p1, p2, q1);
      const o2 = orient(p1, p2, q2);
      const o3 = orient(q1, q2, p1);
      const o4 = orient(q1, q2, p2);

      const intersects =
        (o1 !== o2 && o3 !== o4) ||
        (o1 === 0 && onSegment(p1, q1, p2)) ||
        (o2 === 0 && onSegment(p1, q2, p2)) ||
        (o3 === 0 && onSegment(q1, p1, q2)) ||
        (o4 === 0 && onSegment(q1, p2, q2));

      if (!intersects) return null;

      // Collinear: count only lattice endpoints that lie on other segment
      if (o1 === 0 && onSegment(p1, q1, p2)) return q1;
      if (o2 === 0 && onSegment(p1, q2, p2)) return q2;
      if (o3 === 0 && onSegment(q1, p1, q2)) return p1;
      if (o4 === 0 && onSegment(q1, p2, q2)) return p2;

      // Non-parallel intersection point
      const x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y;
      const x3 = q1.x, y3 = q1.y, x4 = q2.x, y4 = q2.y;

      const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
      if (Math.abs(denom) < eps) return null;

      const px =
        ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / denom;
      const py =
        ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / denom;

      const ix = Math.round(px);
      const iy = Math.round(py);

      if (Math.abs(px - ix) < 1e-6 && Math.abs(py - iy) < 1e-6) {
        const I = { x: ix, y: iy };
        if (onSegment(p1, I, p2) && onSegment(q1, I, q2)) return I;
      }
      return null;
    }

    function keyOf(x, y) {
      return `${x},${y}`;
    }

    function PlayerPill({ player, current }) {
      const label = player === 0 ? "黑方" : "白方";
      return (
        <span
          className={
            "inline-flex items-center gap-2 rounded-full px-3 py-1 text-sm " +
            (current ? "bg-black text-white" : "bg-neutral-200 text-neutral-900")
          }
        >
          <span
            className={
              "h-2.5 w-2.5 rounded-full " +
              (player === 0 ? "bg-white" : "bg-neutral-700")
            }
          />
          {label}
          {current ? "（回合）" : ""}
        </span>
      );
    }

    function ModeButton({ active, onClick, children }) {
      return (
        <button
          onClick={onClick}
          className={
            "rounded-2xl px-4 py-2 text-sm font-medium shadow-sm ring-1 transition active:scale-[0.99] " +
            (active
              ? "bg-neutral-900 text-white ring-neutral-900"
              : "bg-white text-neutral-900 ring-neutral-200 hover:bg-neutral-50")
          }
        >
          {children}
        </button>
      );
    }

    function Toast({ msg, onClose }) {
      if (!msg) return null;
      return (
        <div className="fixed left-1/2 top-4 z-50 -translate-x-1/2">
          <div className="rounded-2xl bg-neutral-900 px-4 py-2 text-sm text-white shadow-lg">
            <div className="flex items-center gap-3">
              <div className="max-w-[70vw] break-words">{msg}</div>
              <button
                className="rounded-lg bg-white/10 px-2 py-1 text-xs hover:bg-white/15"
                onClick={onClose}
              >
                关闭
              </button>
            </div>
          </div>
        </div>
      );
    }

    // ======= App =======
    function App() {
      const [points, setPoints] = useState(() => new Map()); // key -> point
      const [lines, setLines] = useState([]);
      const [turn, setTurn] = useState(0);
      const currentPlayer = turn % 2;

      const [mode, setMode] = useState("place"); // place|line
      const [selectedKey, setSelectedKey] = useState(null);
      const [toast, setToast] = useState("");
      const [lastPlaced, setLastPlaced] = useState(null); // {key, owner, turnPlaced}
      const [gameOver, setGameOver] = useState(false);
      const [winner, setWinner] = useState(null);

      const pointByKey = (k) => points.get(k);

      const ownedKeys = useMemo(() => {
        const arr = [[], []];
        points.forEach((p, k) => {
          if (p.owner === 0) arr[0].push(k);
          else arr[1].push(k);
        });
        return arr;
      }, [points]);

      const adjacency = useMemo(() => {
        const adj = [new Map(), new Map()];
        for (const l of lines) {
          const m = adj[l.owner];
          if (!m.has(l.aKey)) m.set(l.aKey, new Set());
          if (!m.has(l.bKey)) m.set(l.bKey, new Set());
          m.get(l.aKey).add(l.bKey);
          m.get(l.bKey).add(l.aKey);
        }
        return adj;
      }, [lines]);

      const lineCrossCountWithOpponent = (a, b, owner) => {
        const opp = 1 - owner;
        let count = 0;
        for (const l of lines) {
          if (l.owner !== opp) continue;
          const p1 = pointByKey(l.aKey);
          const p2 = pointByKey(l.bKey);
          if (!p1 || !p2) continue;
          const inter = segmentLatticeIntersection(a, b, p1, p2);
          if (inter) count += 1;
          if (count > 1) break;
        }
        return count;
      };

      const wouldCreateCycle = (owner, aKey, bKey) => {
        const adj = adjacency[owner];
        if (aKey === bKey) return true;
        if (!adj.has(aKey) || !adj.has(bKey)) return false;
        const seen = new Set([aKey]);
        const stack = [aKey];
        while (stack.length) {
          const cur = stack.pop();
          const ns = adj.get(cur);
          if (!ns) continue;
          for (const nx of ns) {
            if (nx === bKey) return true;
            if (!seen.has(nx)) {
              seen.add(nx);
              stack.push(nx);
            }
          }
        }
        return false;
      };

      const isLegalLine = (owner, aKey, bKey) => {
        const pa = pointByKey(aKey);
        const pb = pointByKey(bKey);
        if (!pa || !pb) return { ok: false, reason: "端点不存在" };
        if (pa.owner !== owner || pb.owner !== owner) return { ok: false, reason: "只能连接己方点" };
        if (aKey === bKey) return { ok: false, reason: "不能连接同一点" };

        for (const l of lines) {
          if (l.owner !== owner) continue;
          if ((l.aKey === aKey && l.bKey === bKey) || (l.aKey === bKey && l.bKey === aKey)) {
            return { ok: false, reason: "该连线已存在" };
          }
        }

        const d = floorDist(pa, pb);
        if (d > 5) return { ok: false, reason: "距离超过 5（欧氏距离向下取整）" };
        if (wouldCreateCycle(owner, aKey, bKey)) return { ok: false, reason: "禁止形成封闭图形（无环）" };

        const crosses = lineCrossCountWithOpponent(pa, pb, owner);
        const diag = isDiagonal(pa, pb);
        if (!diag && crosses > 0) return { ok: false, reason: "非斜线不能穿过对方连线" };
        if (diag && crosses > 1) return { ok: false, reason: "斜线最多穿过对方连线 1 次" };

        return { ok: true };
      };

      const computeIsolatedForPlayer = (p, nowTurn) => {
        if (p.state !== "original") return false;
        if (nowTurn < p.placedTurn + 2) return false; // from next own turn
        const hasLine = lines.some((l) => l.aKey === p.key || l.bKey === p.key);
        if (hasLine) return false;
        for (const k of ownedKeys[p.owner]) {
          if (k === p.key) continue;
          const q = pointByKey(k);
          if (!q) continue;
          if (floorDist(p, q) <= 3) return false;
        }
        return true;
      };

      const applyStartOfTurnChecks = (nowTurn) => {
        setPoints((prev) => {
          const next = new Map(prev);

          // Update isolated state (and revert if no longer isolated — see note in UI)
          next.forEach((p, k) => {
            const p2 = { ...p, key: k };
            const shouldBeIsolated = computeIsolatedForPlayer(p2, nowTurn);
            if (shouldBeIsolated && p2.state === "original") next.set(k, { ...p2, state: "isolated" });
            if (!shouldBeIsolated && p2.state === "isolated") next.set(k, { ...p2, state: "original" });
          });

          // Conversion triggered by last placed point
          if (lastPlaced && lastPlaced.turnPlaced === nowTurn - 1) {
            const triggerOwner = lastPlaced.owner;
            const targetOwner = 1 - triggerOwner;
            const tp = next.get(lastPlaced.key);
            if (tp) {
              next.forEach((p, k) => {
                if (p.owner !== targetOwner) return;
                if (p.state !== "isolated") return;
                const q = { ...p, key: k };
                if (floorDist(tp, q) <= 3) {
                  next.set(k, { ...p, owner: triggerOwner, state: "converted" });
                }
              });
            }
          }

          return next;
        });
      };

      const computeScores = () => {
        const totalLen = [0, 0];
        for (const l of lines) totalLen[l.owner] += l.lenCeil;

        const denom = [0, 0];
        points.forEach((p) => {
          if (p.owner === 0 && p.state !== "converted") denom[0] += 1;
          if (p.owner === 1 && p.state !== "converted") denom[1] += 1;
        });

        const score = [0, 0];
        for (let i = 0; i < 2; i++) {
          if (denom[i] === 0) score[i] = totalLen[i] > 0 ? Infinity : 0;
          else score[i] = totalLen[i] / denom[i];
        }
        return { totalLen, denom, score };
      };

      const { totalLen, denom, score } = useMemo(computeScores, [lines, points]);
      const allEmptyCount = useMemo(() => N * N - points.size, [points]);

      const hasAnyLegalLine = (owner) => {
        const keys = ownedKeys[owner];
        for (let i = 0; i < keys.length; i++) {
          for (let j = i + 1; j < keys.length; j++) {
            const r = isLegalLine(owner, keys[i], keys[j]);
            if (r.ok) return true;
          }
        }
        return false;
      };

      const checkGameOverAtStart = (nowTurn) => {
        const canPlace = allEmptyCount > 0;
        const canLine = hasAnyLegalLine(currentPlayer);
        if (!canPlace && !canLine) {
          setGameOver(true);
          const s0 = score[0], s1 = score[1];
          if (s0 === s1) setWinner("平局");
          else setWinner(s0 > s1 ? "黑方胜" : "白方胜");
          return true;
        }
        return false;
      };

      useEffect(() => {
        if (gameOver) return;
        applyStartOfTurnChecks(turn);
        // eslint-disable-next-line react-hooks/exhaustive-deps
      }, [turn]);

      useEffect(() => {
        if (gameOver) return;
        const t = setTimeout(() => { checkGameOverAtStart(turn); }, 0);
        return () => clearTimeout(t);
        // eslint-disable-next-line react-hooks/exhaustive-deps
      }, [turn, points, lines]);

      const advanceTurn = () => {
        setSelectedKey(null);
        setMode("place");
        setTurn((t) => t + 1);
      };

      const placePoint = (x, y) => {
        if (gameOver) return;
        const k = keyOf(x, y);
        if (points.has(k)) { setToast("该位置已有点"); return; }

        setPoints((prev) => {
          const next = new Map(prev);
          next.set(k, {
            id: `${Date.now()}_${Math.random().toString(16).slice(2)}`,
            x, y,
            owner: currentPlayer,
            state: "original",
            placedTurn: turn,
            key: k,
          });
          return next;
        });

        setLastPlaced({ key: k, owner: currentPlayer, turnPlaced: turn });
        advanceTurn();
      };

      const addLine = (aKey, bKey) => {
        if (gameOver) return;
        const r = isLegalLine(currentPlayer, aKey, bKey);
        if (!r.ok) { setToast(r.reason); return; }
        const a = pointByKey(aKey), b = pointByKey(bKey);
        const lenCeil = ceilLen(a, b);

        setLines((prev) => [...prev, {
          id: `${Date.now()}_${Math.random().toString(16).slice(2)}`,
          aKey, bKey,
          owner: currentPlayer,
          lenCeil,
        }]);

        advanceTurn();
      };

      const onTapGrid = (x, y) => {
        if (gameOver) return;
        if (mode === "place") { placePoint(x, y); return; }

        const k = keyOf(x, y);
        const p = pointByKey(k);
        if (!p) { setToast("连线模式下只能点选已有点"); return; }
        if (p.owner !== currentPlayer) { setToast("只能选择己方点作为端点"); return; }

        if (!selectedKey) { setSelectedKey(k); return; }
        if (selectedKey === k) { setSelectedKey(null); return; }
        addLine(selectedKey, k);
      };

      const reset = () => {
        setPoints(new Map());
        setLines([]);
        setTurn(0);
        setMode("place");
        setSelectedKey(null);
        setToast("");
        setLastPlaced(null);
        setGameOver(false);
        setWinner(null);
      };

      const padding = 24;
      const viewSize = 600;
      const step = (viewSize - padding * 2) / (N - 1);
      const toSvg = (x, y) => ({ sx: padding + x * step, sy: padding + y * step });

      const uiScore = (v) => (v === Infinity ? "∞" : v.toFixed(3));

      return (
        <div className="min-h-screen bg-neutral-50 text-neutral-900">
          <Toast msg={toast} onClose={() => setToast("")} />

          <div className="mx-auto max-w-6xl px-4 py-4">
            <div className="flex flex-col gap-4 lg:flex-row lg:items-start">
              <div className="w-full lg:flex-1">
                <div className="rounded-3xl bg-white p-3 shadow-sm ring-1 ring-neutral-200">
                  <div className="flex items-center justify-between gap-3 px-2 py-2">
                    <div className="flex flex-wrap items-center gap-2">
                      <PlayerPill player={0} current={currentPlayer === 0 && !gameOver} />
                      <PlayerPill player={1} current={currentPlayer === 1 && !gameOver} />
                    </div>
                    <div className="text-sm text-neutral-600">
                      回合：<span className="font-semibold text-neutral-900">{turn + 1}</span>
                    </div>
                  </div>

                  <div className="relative">
                    <svg
                      className="h-[min(78vh,640px)] w-full touch-manipulation select-none"
                      viewBox={`0 0 ${viewSize} ${viewSize}`}
                    >
                      {Array.from({ length: N }).map((_, i) => {
                        const x = padding + i * step;
                        return (
                          <g key={`g-${i}`}>
                            <line x1={x} y1={padding} x2={x} y2={viewSize - padding} stroke="#e5e7eb" strokeWidth={1} />
                            <line x1={padding} y1={x} x2={viewSize - padding} y2={x} stroke="#e5e7eb" strokeWidth={1} />
                          </g>
                        );
                      })}

                      {lines.map((l) => {
                        const a = pointByKey(l.aKey);
                        const b = pointByKey(l.bKey);
                        if (!a || !b) return null;
                        const { sx: x1, sy: y1 } = toSvg(a.x, a.y);
                        const { sx: x2, sy: y2 } = toSvg(b.x, b.y);
                        const stroke = l.owner === 0 ? "#111827" : "#6b7280";
                        return <line key={l.id} x1={x1} y1={y1} x2={x2} y2={y2} stroke={stroke} strokeWidth={3} opacity={0.95} />;
                      })}

                      {selectedKey && pointByKey(selectedKey) ? (() => {
                        const p = pointByKey(selectedKey);
                        const { sx, sy } = toSvg(p.x, p.y);
                        return <circle cx={sx} cy={sy} r={12} fill="none" stroke="#2563eb" strokeWidth={3} />;
                      })() : null}

                      {Array.from(points.entries()).map(([k, p]) => {
                        const { sx, sy } = toSvg(p.x, p.y);
                        const baseFill = p.owner === 0 ? "#111827" : "#f3f4f6";
                        const baseStroke = "#111827";
                        const r = p.state === "converted" ? 7 : 8;
                        const strokeDash = p.state === "converted" ? "4 3" : "";
                        const opacity = p.state === "isolated" ? 0.85 : 1;

                        return (
                          <g key={k}>
                            <circle
                              cx={sx}
                              cy={sy}
                              r={r}
                              fill={baseFill}
                              stroke={baseStroke}
                              strokeWidth={2}
                              strokeDasharray={strokeDash}
                              opacity={opacity}
                            />
                            {p.state === "converted" ? (
                              <circle cx={sx} cy={sy} r={3} fill={p.owner === 0 ? "#f9fafb" : "#111827"} opacity={0.9} />
                            ) : null}
                          </g>
                        );
                      })}

                      {Array.from({ length: N }).flatMap((_, y) =>
                        Array.from({ length: N }).map((__, x) => {
                          const { sx, sy } = toSvg(x, y);
                          return (
                            <circle
                              key={`hit-${x}-${y}`}
                              cx={sx}
                              cy={sy}
                              r={12}
                              fill="transparent"
                              onPointerDown={(e) => { e.preventDefault(); onTapGrid(x, y); }}
                            />
                          );
                        })
                      )}
                    </svg>

                    {gameOver ? (
                      <div className="absolute inset-0 flex items-center justify-center">
                        <div className="w-[min(520px,92%)] rounded-3xl bg-white/95 p-5 text-center shadow-xl ring-1 ring-neutral-200 backdrop-blur">
                          <div className="text-xl font-semibold">游戏结束</div>
                          <div className="mt-2 text-sm text-neutral-700">{winner || "已结算"}</div>
                          <div className="mt-4 grid grid-cols-2 gap-3 text-left">
                            <div className="rounded-2xl bg-neutral-50 p-3 ring-1 ring-neutral-200">
                              <div className="text-sm font-semibold">黑方</div>
                              <div className="mt-1 text-xs text-neutral-600">线长：{totalLen[0]} / 原生点：{denom[0]}</div>
                              <div className="mt-1 text-lg font-semibold">{uiScore(score[0])}</div>
                            </div>
                            <div className="rounded-2xl bg-neutral-50 p-3 ring-1 ring-neutral-200">
                              <div className="text-sm font-semibold">白方</div>
                              <div className="mt-1 text-xs text-neutral-600">线长：{totalLen[1]} / 原生点：{denom[1]}</div>
                              <div className="mt-1 text-lg font-semibold">{uiScore(score[1])}</div>
                            </div>
                          </div>
                          <div className="mt-4 flex justify-center gap-3">
                            <button className="rounded-2xl bg-neutral-900 px-4 py-2 text-sm font-medium text-white shadow-sm" onClick={reset}>
                              重新开始
                            </button>
                          </div>
                        </div>
                      </div>
                    ) : null}
                  </div>
                </div>

                <div className="mt-3 rounded-3xl bg-white p-4 shadow-sm ring-1 ring-neutral-200">
                  <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
                    <div className="flex flex-wrap gap-2">
                      <ModeButton active={mode === "place"} onClick={() => { setMode("place"); setSelectedKey(null); }}>
                        放点
                      </ModeButton>
                      <ModeButton active={mode === "line"} onClick={() => { setMode("line"); setSelectedKey(null); }}>
                        连线
                      </ModeButton>
                      <button
                        className="rounded-2xl bg-white px-4 py-2 text-sm font-medium shadow-sm ring-1 ring-neutral-200 hover:bg-neutral-50"
                        onClick={() => setToast("提示：连线需满足距离≤5（欧氏向下取整）、非斜线不可穿过对方线，斜线最多穿过1次，且禁止成环。孤立/转化在回合开始自动判定。")}
                      >
                        规则提示
                      </button>
                    </div>

                    <button className="rounded-2xl bg-neutral-100 px-4 py-2 text-sm font-medium text-neutral-900 ring-1 ring-neutral-200 hover:bg-neutral-200" onClick={reset}>
                      重置
                    </button>
                  </div>

                  <div className="mt-3 grid grid-cols-1 gap-3 sm:grid-cols-2">
                    <div className="rounded-2xl bg-neutral-50 p-3 ring-1 ring-neutral-200">
                      <div className="text-sm font-semibold">黑方计分</div>
                      <div className="mt-1 text-xs text-neutral-600">线长：{totalLen[0]}（ceil 求和）</div>
                      <div className="text-xs text-neutral-600">原生点：{denom[0]}（不含转化点）</div>
                      <div className="mt-1 text-lg font-semibold">{uiScore(score[0])}</div>
                    </div>
                    <div className="rounded-2xl bg-neutral-50 p-3 ring-1 ring-neutral-200">
                      <div className="text-sm font-semibold">白方计分</div>
                      <div className="mt-1 text-xs text-neutral-600">线长：{totalLen[1]}（ceil 求和）</div>
                      <div className="text-xs text-neutral-600">原生点：{denom[1]}（不含转化点）</div>
                      <div className="mt-1 text-lg font-semibold">{uiScore(score[1])}</div>
                    </div>
                  </div>

                  <div className="mt-3 text-xs leading-5 text-neutral-600">
                    <div className="font-semibold text-neutral-800">状态标识</div>
                    <ul className="mt-1 list-disc pl-5">
                      <li>普通点：原生点</li>
                      <li>略透明：孤立点（满足条件后出现）</li>
                      <li>虚线边框 + 中心小点：转化点（已归属对手，且不计入分母，但可连线）</li>
                    </ul>
                    <div className="mt-2">注：此网页版本中，孤立点若不再满足条件会恢复为原生点（为了在线判定明确且可解释）。若你希望“孤立不可逆”，我可以给你一个开关版本。</div>
                  </div>
                </div>
              </div>

              <div className="w-full lg:w-[360px]">
                <div className="rounded-3xl bg-white p-4 shadow-sm ring-1 ring-neutral-200">
                  <div className="text-sm font-semibold">操作说明</div>
                  <div className="mt-2 space-y-2 text-sm text-neutral-700">
                    <div className="rounded-2xl bg-neutral-50 p-3 ring-1 ring-neutral-200">
                      <div className="font-semibold">放点</div>
                      <div className="mt-1 text-xs text-neutral-600">点击/轻触任意空格点放置原生点（允许自杀式放点）。</div>
                    </div>
                    <div className="rounded-2xl bg-neutral-50 p-3 ring-1 ring-neutral-200">
                      <div className="font-semibold">连线</div>
                      <div className="mt-1 text-xs text-neutral-600">先点己方点选中，再点另一己方点完成连线；重复点同一点可取消。</div>
                    </div>
                    <div className="rounded-2xl bg-neutral-50 p-3 ring-1 ring-neutral-200">
                      <div className="font-semibold">回合开始自动判定</div>
                      <div className="mt-1 text-xs text-neutral-600">孤立与转化均在回合开始时自动执行，不允许反应操作。</div>
                    </div>
                  </div>
                </div>

                <div className="mt-3 rounded-3xl bg-white p-4 shadow-sm ring-1 ring-neutral-200">
                  <div className="text-sm font-semibold">当前规则参数</div>
                  <div className="mt-2 grid grid-cols-2 gap-2 text-xs text-neutral-700">
                    <div className="rounded-2xl bg-neutral-50 p-3 ring-1 ring-neutral-200">
                      连线距离<div className="mt-1 text-sm font-semibold">≤ 5</div>
                    </div>
                    <div className="rounded-2xl bg-neutral-50 p-3 ring-1 ring-neutral-200">
                      孤立半径<div className="mt-1 text-sm font-semibold">≤ 3</div>
                    </div>
                    <div className="rounded-2xl bg-neutral-50 p-3 ring-1 ring-neutral-200">
                      距离规则<div className="mt-1 text-sm font-semibold">欧氏向下取整</div>
                    </div>
                    <div className="rounded-2xl bg-neutral-50 p-3 ring-1 ring-neutral-200">
                      禁止结构<div className="mt-1 text-sm font-semibold">无环（森林）</div>
                    </div>
                  </div>
                </div>

                <div className="mt-3 rounded-3xl bg-white p-4 shadow-sm ring-1 ring-neutral-200">
                  <div className="text-sm font-semibold">对局信息</div>
                  <div className="mt-2 space-y-2 text-xs text-neutral-700">
                    <div className="flex items-center justify-between rounded-2xl bg-neutral-50 px-3 py-2 ring-1 ring-neutral-200">
                      <span>剩余空点</span><span className="font-semibold">{allEmptyCount}</span>
                    </div>
                    <div className="flex items-center justify-between rounded-2xl bg-neutral-50 px-3 py-2 ring-1 ring-neutral-200">
                      <span>当前模式</span><span className="font-semibold">{mode === "place" ? "放点" : "连线"}</span>
                    </div>
                    <div className="flex items-center justify-between rounded-2xl bg-neutral-50 px-3 py-2 ring-1 ring-neutral-200">
                      <span>已选端点</span><span className="font-semibold">{selectedKey || "无"}</span>
                    </div>
                    <div className="flex items-center justify-between rounded-2xl bg-neutral-50 px-3 py-2 ring-1 ring-neutral-200">
                      <span>上一步放点</span><span className="font-semibold">{lastPlaced ? lastPlaced.key : "无"}</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <div className="mt-4 text-center text-xs text-neutral-500">
              Isolaton and Relation • 纯静态网页 • 双人同屏（手机/电脑自适应）
            </div>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(<App />);
  </script>
</body>
</html>
