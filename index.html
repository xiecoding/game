<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Isolaton and Relation — 双人同屏（纯静态 v2）</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    html, body { height: 100%; }
  </style>
</head>
<body class="bg-neutral-50">
  <div id="root"></div>

  <script type="text/babel">
    const { useEffect, useMemo, useState } = React;

    const N = 16;

    function floorDist(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      return Math.floor(Math.hypot(dx, dy));
    }
    function ceilLen(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      return Math.ceil(Math.hypot(dx, dy));
    }
    function isDiagonal(a, b) {
      const dx = Math.abs(a.x - b.x);
      const dy = Math.abs(a.y - b.y);
      return dx === dy && dx !== 0;
    }

    function segmentLatticeIntersection(p1, p2, q1, q2) {
      const eps = 1e-9;

      const onSegment = (a, b, c) =>
        Math.min(a.x, c.x) - eps <= b.x &&
        b.x <= Math.max(a.x, c.x) + eps &&
        Math.min(a.y, c.y) - eps <= b.y &&
        b.y <= Math.max(a.y, c.y) + eps;

      const orient = (a, b, c) => {
        const v = (b.y - a.y) * (c.x - b.x) - (b.x - a.x) * (c.y - b.y);
        if (Math.abs(v) < eps) return 0;
        return v > 0 ? 1 : 2;
      };

      const shareEndpoint = (a, b, c, d) => {
        const eq = (u, v) => u.x === v.x && u.y === v.y;
        if (eq(a, c)) return a;
        if (eq(a, d)) return a;
        if (eq(b, c)) return b;
        if (eq(b, d)) return b;
        return null;
      };

      const shared = shareEndpoint(p1, p2, q1, q2);
      if (shared) return shared;

      const o1 = orient(p1, p2, q1);
      const o2 = orient(p1, p2, q2);
      const o3 = orient(q1, q2, p1);
      const o4 = orient(q1, q2, p2);

      const intersects =
        (o1 !== o2 && o3 !== o4) ||
        (o1 === 0 && onSegment(p1, q1, p2)) ||
        (o2 === 0 && onSegment(p1, q2, p2)) ||
        (o3 === 0 && onSegment(q1, p1, q2)) ||
        (o4 === 0 && onSegment(q1, p2, q2));

      if (!intersects) return null;

      if (o1 === 0 && onSegment(p1, q1, p2)) return q1;
      if (o2 === 0 && onSegment(p1, q2, p2)) return q2;
      if (o3 === 0 && onSegment(q1, p1, q2)) return p1;
      if (o4 === 0 && onSegment(q1, p2, q2)) return p2;

      const x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y;
      const x3 = q1.x, y3 = q1.y, x4 = q2.x, y4 = q2.y;

      const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
      if (Math.abs(denom) < eps) return null;

      const px =
        ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / denom;
      const py =
        ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / denom;

      const ix = Math.round(px);
      const iy = Math.round(py);

      if (Math.abs(px - ix) < 1e-6 && Math.abs(py - iy) < 1e-6) {
        const I = { x: ix, y: iy };
        if (onSegment(p1, I, p2) && onSegment(q1, I, q2)) return I;
      }
      return null;
    }

    function keyOf(x, y) { return `${x},${y}`; }

    function PlayerPill({ player, current }) {
      const label = player === 0 ? "黑方" : "白方";
      return (
        <span className={"inline-flex items-center gap-2 rounded-full px-3 py-1 text-sm " + (current ? "bg-black text-white" : "bg-neutral-200 text-neutral-900")}>
          <span className={"h-2.5 w-2.5 rounded-full " + (player === 0 ? "bg-white" : "bg-neutral-700")} />
          {label}{current ? "（回合）" : ""}
        </span>
      );
    }

    function ModeButton({ active, onClick, children }) {
      return (
        <button
          onClick={onClick}
          className={"rounded-2xl px-4 py-2 text-sm font-medium shadow-sm ring-1 transition active:scale-[0.99] " +
            (active ? "bg-neutral-900 text-white ring-neutral-900" : "bg-white text-neutral-900 ring-neutral-200 hover:bg-neutral-50")}
        >
          {children}
        </button>
      );
    }

    function Toast({ msg, onClose }) {
      if (!msg) return null;
      return (
        <div className="fixed left-1/2 top-4 z-50 -translate-x-1/2">
          <div className="rounded-2xl bg-neutral-900 px-4 py-2 text-sm text-white shadow-lg">
            <div className="flex items-center gap-3">
              <div className="max-w-[70vw] break-words">{msg}</div>
              <button className="rounded-lg bg-white/10 px-2 py-1 text-xs hover:bg-white/15" onClick={onClose}>关闭</button>
            </div>
          </div>
        </div>
      );
    }

    function hasIncidentLine(lines, key) {
      for (const l of lines) if (l.aKey === key || l.bKey === key) return true;
      return false;
    }

    function App() {
      const [points, setPoints] = useState(() => new Map());
      const [lines, setLines] = useState([]);
      const [turn, setTurn] = useState(0);
      const currentPlayer = turn % 2;

      const [mode, setMode] = useState("place");
      const [selectedKey, setSelectedKey] = useState(null);
      const [toast, setToast] = useState("");

      const [gameOver, setGameOver] = useState(false);
      const [winner, setWinner] = useState(null);

      const pointByKey = (k, map = points) => map.get(k);

      const ownedKeys = useMemo(() => {
        const arr = [[], []];
        points.forEach((p, k) => { (p.owner === 0 ? arr[0] : arr[1]).push(k); });
        return arr;
      }, [points]);

      const adjacency = useMemo(() => {
        const adj = [new Map(), new Map()];
        for (const l of lines) {
          const m = adj[l.owner];
          if (!m.has(l.aKey)) m.set(l.aKey, new Set());
          if (!m.has(l.bKey)) m.set(l.bKey, new Set());
          m.get(l.aKey).add(l.bKey);
          m.get(l.bKey).add(l.aKey);
        }
        return adj;
      }, [lines]);

      const lineCrossCountWithOpponent = (a, b, owner) => {
        const opp = 1 - owner;
        let count = 0;
        for (const l of lines) {
          if (l.owner !== opp) continue;
          const p1 = pointByKey(l.aKey);
          const p2 = pointByKey(l.bKey);
          if (!p1 || !p2) continue;
          const inter = segmentLatticeIntersection(a, b, p1, p2);
          if (inter) count += 1;
          if (count > 1) break;
        }
        return count;
      };

      const wouldCreateCycle = (owner, aKey, bKey) => {
        const adj = adjacency[owner];
        if (aKey === bKey) return true;
        if (!adj.has(aKey) || !adj.has(bKey)) return false;
        const seen = new Set([aKey]);
        const stack = [aKey];
        while (stack.length) {
          const cur = stack.pop();
          const ns = adj.get(cur);
          if (!ns) continue;
          for (const nx of ns) {
            if (nx === bKey) return true;
            if (!seen.has(nx)) { seen.add(nx); stack.push(nx); }
          }
        }
        return false;
      };

      const isLegalLine = (owner, aKey, bKey) => {
        const pa = pointByKey(aKey);
        const pb = pointByKey(bKey);
        if (!pa || !pb) return { ok: false, reason: "端点不存在" };
        if (pa.owner !== owner || pb.owner !== owner) return { ok: false, reason: "只能连接己方点" };
        if (aKey === bKey) return { ok: false, reason: "不能连接同一点" };

        for (const l of lines) {
          if (l.owner !== owner) continue;
          if ((l.aKey === aKey && l.bKey === bKey) || (l.aKey === bKey && l.bKey === aKey)) {
            return { ok: false, reason: "该连线已存在" };
          }
        }

        const d = floorDist(pa, pb);
        if (d > 5) return { ok: false, reason: "距离超过 5（欧氏距离向下取整）" };
        if (wouldCreateCycle(owner, aKey, bKey)) return { ok: false, reason: "禁止形成封闭图形（无环）" };

        const crosses = lineCrossCountWithOpponent(pa, pb, owner);
        const diag = isDiagonal(pa, pb);
        if (!diag && crosses > 0) return { ok: false, reason: "非斜线不能穿过对方连线" };
        if (diag && crosses > 1) return { ok: false, reason: "斜线最多穿过对方连线 1 次" };
        return { ok: true };
      };

      const computeIsolatedForPoint = (p, nowTurn, map, linesForCheck) => {
        if (p.state === "converted") return false;
        if (p.state !== "original" && p.state !== "isolated") return false;
        if (nowTurn < p.placedTurn + 2) return false;
        if (hasIncidentLine(linesForCheck, p.key)) return false;

        for (const [k2, q] of map.entries()) {
          if (k2 === p.key) continue;
          if (q.owner !== p.owner) continue;
          if (floorDist(p, { ...q, key: k2 }) <= 3) return false;
        }
        return true;
      };

      const updateIsolatedStates = (nowTurn, map, linesForCheck) => {
        const next = new Map(map);
        for (const [k, p] of next.entries()) {
          const p2 = { ...p, key: k };
          if (p2.state === "converted") continue;
          const shouldBeIso = computeIsolatedForPoint(p2, nowTurn, next, linesForCheck);
          if (shouldBeIso && p2.state === "original") next.set(k, { ...p2, state: "isolated" });
          if (!shouldBeIso && p2.state === "isolated") next.set(k, { ...p2, state: "original" });
        }
        return next;
      };

      const endOfTurnConversion = (map) => {
        const next = new Map(map);
        for (const [k, p] of next.entries()) {
          if (p.state !== "isolated") continue;
          const owner = p.owner;
          const opp = 1 - owner;
          const P = { ...p, key: k };

          let threatened = false;
          for (const [k2, q] of next.entries()) {
            if (q.owner !== opp) continue;
            const Q = { ...q, key: k2 };
            if (floorDist(P, Q) <= 3) { threatened = true; break; }
          }
          if (threatened) next.set(k, { ...p, owner: opp, state: "converted" });
        }
        return next;
      };

      const settleEndOfTurn = (nowTurn, map, linesForCheck) => {
        const afterIso = updateIsolatedStates(nowTurn, map, linesForCheck);
        return endOfTurnConversion(afterIso);
      };

      const computeScores = () => {
        const totalLen = [0, 0];
        for (const l of lines) totalLen[l.owner] += l.lenCeil;

        const denom = [0, 0];
        points.forEach((p) => {
          if (p.owner === 0 && p.state !== "converted") denom[0] += 1;
          if (p.owner === 1 && p.state !== "converted") denom[1] += 1;
        });

        const score = [0, 0];
        for (let i = 0; i < 2; i++) {
          if (denom[i] === 0) score[i] = totalLen[i] > 0 ? Infinity : 0;
          else score[i] = totalLen[i] / denom[i];
        }
        return { totalLen, denom, score };
      };

      const { totalLen, denom, score } = useMemo(computeScores, [lines, points]);
      const allEmptyCount = useMemo(() => N * N - points.size, [points]);

      const hasAnyLegalLine = (owner) => {
        const keys = ownedKeys[owner];
        for (let i = 0; i < keys.length; i++) {
          for (let j = i + 1; j < keys.length; j++) {
            const r = isLegalLine(owner, keys[i], keys[j]);
            if (r.ok) return true;
          }
        }
        return false;
      };

      const checkGameOverAtStart = () => {
        const canPlace = allEmptyCount > 0;
        const canLine = hasAnyLegalLine(currentPlayer);
        if (!canPlace && !canLine) {
          setGameOver(true);
          const s0 = score[0], s1 = score[1];
          if (s0 === s1) setWinner("平局");
          else setWinner(s0 > s1 ? "黑方胜" : "白方胜");
          return true;
        }
        return false;
      };

      useEffect(() => {
        if (gameOver) return;
        setPoints((prev) => updateIsolatedStates(turn, prev, lines));
        // eslint-disable-next-line react-hooks/exhaustive-deps
      }, [turn]);

      useEffect(() => {
        if (gameOver) return;
        const t = setTimeout(() => { checkGameOverAtStart(); }, 0);
        return () => clearTimeout(t);
        // eslint-disable-next-line react-hooks/exhaustive-deps
      }, [turn, points, lines]);

      const advanceTurn = () => {
        setSelectedKey(null);
        setMode("place");
        setTurn((t) => t + 1);
      };

      const placePoint = (x, y) => {
        if (gameOver) return;
        const k = keyOf(x, y);
        if (points.has(k)) { setToast("该位置已有点"); return; }

        const placed = new Map(points);
        placed.set(k, { x, y, owner: currentPlayer, state: "original", placedTurn: turn });

        const settled = settleEndOfTurn(turn, placed, lines);
        setPoints(settled);
        advanceTurn();
      };

      const addLine = (aKey, bKey) => {
        if (gameOver) return;
        const r = isLegalLine(currentPlayer, aKey, bKey);
        if (!r.ok) { setToast(r.reason); return; }

        const a = pointByKey(aKey);
        const b = pointByKey(bKey);
        const lenCeil = ceilLen(a, b);

        const nextLines = [...lines, {
          id: `${Date.now()}_${Math.random().toString(16).slice(2)}`,
          aKey, bKey, owner: currentPlayer, lenCeil
        }];

        const settled = settleEndOfTurn(turn, points, nextLines);
        setLines(nextLines);
        setPoints(settled);
        advanceTurn();
      };

      const onTapGrid = (x, y) => {
        if (gameOver) return;
        if (mode === "place") { placePoint(x, y); return; }

        const k = keyOf(x, y);
        const p = pointByKey(k);
        if (!p) { setToast("连线模式下只能点选已有点"); return; }
        if (p.owner !== currentPlayer) { setToast("只能选择己方点作为端点"); return; }

        if (!selectedKey) { setSelectedKey(k); return; }
        if (selectedKey === k) { setSelectedKey(null); return; }
        addLine(selectedKey, k);
      };

      const reset = () => {
        setPoints(new Map());
        setLines([]);
        setTurn(0);
        setMode("place");
        setSelectedKey(null);
        setToast("");
        setGameOver(false);
        setWinner(null);
      };

      const padding = 24;
      const viewSize = 600;
      const step = (viewSize - padding * 2) / (N - 1);
      const toSvg = (x, y) => ({ sx: padding + x * step, sy: padding + y * step });
      const uiScore = (v) => (v === Infinity ? "∞" : v.toFixed(3));

      return (
        <div className="min-h-screen bg-neutral-50 text-neutral-900">
          <Toast msg={toast} onClose={() => setToast("")} />

          <div className="mx-auto max-w-6xl px-4 py-4">
            <div className="flex flex-col gap-4 lg:flex-row lg:items-start">
              <div className="w-full lg:flex-1">
                <div className="rounded-3xl bg-white p-3 shadow-sm ring-1 ring-neutral-200">
                  <div className="flex items-center justify-between gap-3 px-2 py-2">
                    <div className="flex flex-wrap items-center gap-2">
                      <PlayerPill player={0} current={currentPlayer === 0 && !gameOver} />
                      <PlayerPill player={1} current={currentPlayer === 1 && !gameOver} />
                    </div>
                    <div className="text-sm text-neutral-600">回合：<span className="font-semibold text-neutral-900">{turn + 1}</span></div>
                  </div>

                  <div className="relative">
                    <svg className="h-[min(78vh,640px)] w-full touch-manipulation select-none" viewBox={`0 0 ${viewSize} ${viewSize}`}>
                      {Array.from({ length: N }).map((_, i) => {
                        const x = padding + i * step;
                        return (
                          <g key={`g-${i}`}>
                            <line x1={x} y1={padding} x2={x} y2={viewSize - padding} stroke="#e5e7eb" strokeWidth={1} />
                            <line x1={padding} y1={x} x2={viewSize - padding} y2={x} stroke="#e5e7eb" strokeWidth={1} />
                          </g>
                        );
                      })}

                      {lines.map((l) => {
                        const a = points.get(l.aKey);
                        const b = points.get(l.bKey);
                        if (!a || !b) return null;
                        const { sx: x1, sy: y1 } = toSvg(a.x, a.y);
                        const { sx: x2, sy: y2 } = toSvg(b.x, b.y);
                        const stroke = l.owner === 0 ? "#111827" : "#6b7280";
                        return <line key={l.id} x1={x1} y1={y1} x2={x2} y2={y2} stroke={stroke} strokeWidth={3} opacity={0.95} />;
                      })}

                      {selectedKey && points.get(selectedKey) ? (() => {
                        const p = points.get(selectedKey);
                        const { sx, sy } = toSvg(p.x, p.y);
                        return <circle cx={sx} cy={sy} r={12} fill="none" stroke="#2563eb" strokeWidth={3} />;
                      })() : null}

                      {Array.from(points.entries()).map(([k, p]) => {
                        const { sx, sy } = toSvg(p.x, p.y);
                        const baseFill = p.owner === 0 ? "#111827" : "#f3f4f6";
                        const baseStroke = "#111827";

                        const isConverted = p.state === "converted";
                        const isIsolated = p.state === "isolated";

                        const r = isConverted ? 7 : 8;
                        const strokeDash = isConverted ? "4 3" : "";
                        const opacity = isIsolated ? 0.95 : 1;

                        return (
                          <g key={k}>
                            {/* 额外标识：孤立点外圈 */}
                            {isIsolated ? (
                              <circle
                                cx={sx}
                                cy={sy}
                                r={r + 5}
                                fill="none"
                                stroke="#f59e0b"
                                strokeWidth={3}
                                strokeDasharray="6 4"
                                opacity={0.95}
                              />
                            ) : null}

                            {/* 点本体 */}
                            <circle
                              cx={sx}
                              cy={sy}
                              r={r}
                              fill={baseFill}
                              stroke={baseStroke}
                              strokeWidth={2}
                              strokeDasharray={strokeDash}
                              opacity={opacity}
                            />

                            {/* 转化点中心标记 */}
                            {isConverted ? (
                              <circle
                                cx={sx}
                                cy={sy}
                                r={3}
                                fill={p.owner === 0 ? "#f9fafb" : "#111827"}
                                opacity={0.9}
                              />
                            ) : null}
                          </g>
                        );
                      })}

                      {Array.from({ length: N }).flatMap((_, y) =>
                        Array.from({ length: N }).map((__, x) => {
                          const { sx, sy } = toSvg(x, y);
                          return (
                            <circle key={`hit-${x}-${y}`} cx={sx} cy={sy} r={12} fill="transparent"
                              onPointerDown={(e) => { e.preventDefault(); onTapGrid(x, y); }} />
                          );
                        })
                      )}
                    </svg>

                    {gameOver ? (
                      <div className="absolute inset-0 flex items-center justify-center">
                        <div className="w-[min(520px,92%)] rounded-3xl bg-white/95 p-5 text-center shadow-xl ring-1 ring-neutral-200 backdrop-blur">
                          <div className="text-xl font-semibold">游戏结束</div>
                          <div className="mt-2 text-sm text-neutral-700">{winner || "已结算"}</div>
                          <div className="mt-4 grid grid-cols-2 gap-3 text-left">
                            <div className="rounded-2xl bg-neutral-50 p-3 ring-1 ring-neutral-200">
                              <div className="text-sm font-semibold">黑方</div>
                              <div className="mt-1 text-xs text-neutral-600">线长：{totalLen[0]} / 原生点：{denom[0]}</div>
                              <div className="mt-1 text-lg font-semibold">{uiScore(score[0])}</div>
                            </div>
                            <div className="rounded-2xl bg-neutral-50 p-3 ring-1 ring-neutral-200">
                              <div className="text-sm font-semibold">白方</div>
                              <div className="mt-1 text-xs text-neutral-600">线长：{totalLen[1]} / 原生点：{denom[1]}</div>
                              <div className="mt-1 text-lg font-semibold">{uiScore(score[1])}</div>
                            </div>
                          </div>
                          <div className="mt-4 flex justify-center gap-3">
                            <button className="rounded-2xl bg-neutral-900 px-4 py-2 text-sm font-medium text-white shadow-sm" onClick={reset}>重新开始</button>
                          </div>
                        </div>
                      </div>
                    ) : null}
                  </div>
                </div>

                <div className="mt-3 rounded-3xl bg-white p-4 shadow-sm ring-1 ring-neutral-200">
                  <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
                    <div className="flex flex-wrap gap-2">
                      <ModeButton active={mode === "place"} onClick={() => { setMode("place"); setSelectedKey(null); }}>放点</ModeButton>
                      <ModeButton active={mode === "line"} onClick={() => { setMode("line"); setSelectedKey(null); }}>连线</ModeButton>
                      <button className="rounded-2xl bg-white px-4 py-2 text-sm font-medium shadow-sm ring-1 ring-neutral-200 hover:bg-neutral-50"
                        onClick={() => setToast("提示：距离判定用欧氏向下取整；计分线长用欧氏向上取整。转化只在回合结束判定：先更新孤立，再检查孤立点半径3内是否有任意对方点（含转化点）。")}>
                        规则提示
                      </button>
                    </div>
                    <button className="rounded-2xl bg-neutral-100 px-4 py-2 text-sm font-medium text-neutral-900 ring-1 ring-neutral-200 hover:bg-neutral-200" onClick={reset}>重置</button>
                  </div>

                  <div className="mt-3 grid grid-cols-1 gap-3 sm:grid-cols-2">
                    <div className="rounded-2xl bg-neutral-50 p-3 ring-1 ring-neutral-200">
                      <div className="text-sm font-semibold">黑方计分</div>
                      <div className="mt-1 text-xs text-neutral-600">线长：{totalLen[0]}（ceil 求和）</div>
                      <div className="text-xs text-neutral-600">原生点：{denom[0]}（不含转化点）</div>
                      <div className="mt-1 text-lg font-semibold">{uiScore(score[0])}</div>
                    </div>
                    <div className="rounded-2xl bg-neutral-50 p-3 ring-1 ring-neutral-200">
                      <div className="text-sm font-semibold">白方计分</div>
                      <div className="mt-1 text-xs text-neutral-600">线长：{totalLen[1]}（ceil 求和）</div>
                      <div className="text-xs text-neutral-600">原生点：{denom[1]}（不含转化点）</div>
                      <div className="mt-1 text-lg font-semibold">{uiScore(score[1])}</div>
                    </div>
                  </div>

                  <div className="mt-3 text-xs leading-5 text-neutral-600">
                    <div className="font-semibold text-neutral-800">图例（点的含义）</div>
                    <div className="mt-2 space-y-2">
                      <div className="flex items-center gap-3">
                        <svg width="28" height="28" viewBox="0 0 28 28" aria-hidden="true">
                          <circle cx="14" cy="14" r="8" fill="#111827" stroke="#111827" stroke-width="2" />
                        </svg>
                        <div className="text-xs text-neutral-700">原生点（普通点）</div>
                      </div>

                      <div className="flex items-center gap-3">
                        <svg width="28" height="28" viewBox="0 0 28 28" aria-hidden="true">
                          <circle cx="14" cy="14" r="13" fill="none" stroke="#f59e0b" stroke-width="3" stroke-dasharray="6 4" />
                          <circle cx="14" cy="14" r="8" fill="#111827" stroke="#111827" stroke-width="2" />
                        </svg>
                        <div className="text-xs text-neutral-700">孤立点（被标记为“孤立”的原生点）</div>
                      </div>

                      <div className="flex items-center gap-3">
                        <svg width="28" height="28" viewBox="0 0 28 28" aria-hidden="true">
                          <circle cx="14" cy="14" r="7" fill="#f3f4f6" stroke="#111827" stroke-width="2" stroke-dasharray="4 3" />
                          <circle cx="14" cy="14" r="3" fill="#111827" opacity="0.9" />
                        </svg>
                        <div className="text-xs text-neutral-700">转化点（归属对手；可连线）</div>
                      </div>
                    </div>
                    <div className="mt-2">转化只在回合结束判定：先更新孤立，再检查孤立点半径3内是否存在任意对方点（包括对方转化点）。</div>
                  </div>
                </div>
              </div>

              <div className="w-full lg:w-[360px]">
                <div className="rounded-3xl bg-white p-4 shadow-sm ring-1 ring-neutral-200">
                  <div className="text-sm font-semibold">操作说明</div>
                  <div className="mt-2 space-y-2 text-sm text-neutral-700">
                    <div className="rounded-2xl bg-neutral-50 p-3 ring-1 ring-neutral-200">
                      <div className="font-semibold">放点</div>
                      <div className="mt-1 text-xs text-neutral-600">点击/轻触任意空格点放置原生点（允许自杀式放点）。</div>
                    </div>
                    <div className="rounded-2xl bg-neutral-50 p-3 ring-1 ring-neutral-200">
                      <div className="font-semibold">连线</div>
                      <div className="mt-1 text-xs text-neutral-600">先点己方点选中，再点另一个己方点完成连线；重复点同一点可取消。</div>
                    </div>
                    <div className="rounded-2xl bg-neutral-50 p-3 ring-1 ring-neutral-200">
                      <div className="font-semibold">结算时点</div>
                      <div className="mt-1 text-xs text-neutral-600">孤立状态会在回合开始更新；转化仅在回合结束执行（先更新孤立，再转化）。</div>
                    </div>
                  </div>
                </div>

                <div className="mt-3 rounded-3xl bg-white p-4 shadow-sm ring-1 ring-neutral-200">
                  <div className="text-sm font-semibold">当前规则参数</div>
                  <div className="mt-2 grid grid-cols-2 gap-2 text-xs text-neutral-700">
                    <div className="rounded-2xl bg-neutral-50 p-3 ring-1 ring-neutral-200">连线距离<div className="mt-1 text-sm font-semibold">≤ 5（floor）</div></div>
                    <div className="rounded-2xl bg-neutral-50 p-3 ring-1 ring-neutral-200">孤立半径<div className="mt-1 text-sm font-semibold">≤ 3（floor）</div></div>
                    <div className="rounded-2xl bg-neutral-50 p-3 ring-1 ring-neutral-200">线长计分<div className="mt-1 text-sm font-semibold">欧氏向上取整</div></div>
                    <div className="rounded-2xl bg-neutral-50 p-3 ring-1 ring-neutral-200">禁止结构<div className="mt-1 text-sm font-semibold">无环（森林）</div></div>
                  </div>
                </div>

                <div className="mt-3 rounded-3xl bg-white p-4 shadow-sm ring-1 ring-neutral-200">
                  <div className="text-sm font-semibold">对局信息</div>
                  <div className="mt-2 space-y-2 text-xs text-neutral-700">
                    <div className="flex items-center justify-between rounded-2xl bg-neutral-50 px-3 py-2 ring-1 ring-neutral-200"><span>剩余空点</span><span className="font-semibold">{allEmptyCount}</span></div>
                    <div className="flex items-center justify-between rounded-2xl bg-neutral-50 px-3 py-2 ring-1 ring-neutral-200"><span>当前模式</span><span className="font-semibold">{mode === "place" ? "放点" : "连线"}</span></div>
                    <div className="flex items-center justify-between rounded-2xl bg-neutral-50 px-3 py-2 ring-1 ring-neutral-200"><span>已选端点</span><span className="font-semibold">{selectedKey || "无"}</span></div>
                  </div>
                </div>
              </div>
            </div>

            <div className="mt-4 text-center text-xs text-neutral-500">
              Isolaton and Relation • 纯静态网页 v2 • 双人同屏（手机/电脑自适应）
            </div>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(<App />);
  </script>
</body>
</html>
